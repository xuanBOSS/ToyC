// ==== codegen/codegen.cpp ====
// codegen.cpp
#include "codegen.h"
#include <sstream>
#include <iostream>
#include <cassert>
CodeGenerator::CodeGenerator(const std::string& outputFile, const std::vector<std::shared_ptr<IRInstr>>& instructions)
    : instructions(instructions) {
    output.open(outputFile);
    if (!output) {
        std::cerr << "Error: Could not open output file: " << outputFile << std::endl;
        exit(1);
    }
    
    // 输出文件头
    emitComment("Generated by ToyC Compiler");
    emitComment("RISC-V Assembly Code");
    output << "\t.text\n";
}

CodeGenerator::~CodeGenerator() {
    if (output.is_open()) {
        output.close();
    }
}

void CodeGenerator::generate() {
    // 处理所有IR指令
    for (const auto& instr : instructions) {
        processInstruction(instr);
    }
}

std::string CodeGenerator::genLabel() {
    return "L" + std::to_string(labelCount++);
}

void CodeGenerator::emitComment(const std::string& comment) {
    output << "\t# " << comment << "\n";
}

void CodeGenerator::emitInstruction(const std::string& instr) {
    output << "\t" << instr << "\n";
}

void CodeGenerator::processInstruction(const std::shared_ptr<IRInstr>& instr) {
    // 根据指令类型调用相应的处理函数
    switch (instr->opcode) {
        case OpCode::ADD:
        case OpCode::SUB:
        case OpCode::MUL:
        case OpCode::DIV:
        case OpCode::MOD:
        case OpCode::LT:
        case OpCode::GT:
        case OpCode::LE:
        case OpCode::GE:
        case OpCode::EQ:
        case OpCode::NE:
        case OpCode::AND:
        case OpCode::OR:
            processBinaryOp(std::dynamic_pointer_cast<BinaryOpInstr>(instr));
            break;
            
        case OpCode::NEG:
        case OpCode::NOT:
            processUnaryOp(std::dynamic_pointer_cast<UnaryOpInstr>(instr));
            break;
            
        case OpCode::ASSIGN:
            processAssign(std::dynamic_pointer_cast<AssignInstr>(instr));
            break;
            
        case OpCode::GOTO:
            processGoto(std::dynamic_pointer_cast<GotoInstr>(instr));
            break;
            
        case OpCode::IF_GOTO:
            processIfGoto(std::dynamic_pointer_cast<IfGotoInstr>(instr));
            break;
            
        case OpCode::PARAM:
            processParam(std::dynamic_pointer_cast<ParamInstr>(instr));
            break;
            
        case OpCode::CALL:
            processCall(std::dynamic_pointer_cast<CallInstr>(instr));
            break;
            
        case OpCode::RETURN:
            processReturn(std::dynamic_pointer_cast<ReturnInstr>(instr));
            break;
            
        case OpCode::LABEL:
            processLabel(std::dynamic_pointer_cast<LabelInstr>(instr));
            break;
            
        case OpCode::FUNCTION_BEGIN:
            processFunctionBegin(std::dynamic_pointer_cast<FunctionBeginInstr>(instr));
            break;
            
        case OpCode::FUNCTION_END:
            processFunctionEnd(std::dynamic_pointer_cast<FunctionEndInstr>(instr));
            break;
            
        default:
            std::cerr << "Error: Unknown instruction type" << std::endl;
            break;
    }
}

void CodeGenerator::processBinaryOp(const std::shared_ptr<BinaryOpInstr>& instr) {
    emitComment(instr->toString());
    
    // 加载左操作数到a0
    loadOperand(instr->left, "a0");
    
    // 加载右操作数到a1
    loadOperand(instr->right, "a1");
    
    // 根据操作码生成相应的指令
    switch (instr->opcode) {
        case OpCode::ADD:
            emitInstruction("add a0, a0, a1");
            break;
        case OpCode::SUB:
            emitInstruction("sub a0, a0, a1");
            break;
        case OpCode::MUL:
            emitInstruction("mul a0, a0, a1");
            break;
        case OpCode::DIV:
            emitInstruction("div a0, a0, a1");
            break;
        case OpCode::MOD:
            emitInstruction("rem a0, a0, a1");
            break;
        case OpCode::LT:
            emitInstruction("slt a0, a0, a1");
            break;
        case OpCode::GT:
            emitInstruction("slt a0, a1, a0");
            break;
        case OpCode::LE:
            emitInstruction("slt a0, a1, a0");
            emitInstruction("xori a0, a0, 1");
            break;
        case OpCode::GE:
            emitInstruction("slt a0, a0, a1");
            emitInstruction("xori a0, a0, 1");
            break;
        case OpCode::EQ:
            emitInstruction("xor a0, a0, a1");
            emitInstruction("seqz a0, a0");
            break;
        case OpCode::NE:
            emitInstruction("xor a0, a0, a1");
            emitInstruction("snez a0, a0");
            break;
        case OpCode::AND:
            emitInstruction("snez a0, a0");
            emitInstruction("snez a1, a1");
            emitInstruction("and a0, a0, a1");
            break;
        case OpCode::OR:
            emitInstruction("or a0, a0, a1");
            emitInstruction("snez a0, a0");
            break;
        default:
            std::cerr << "Error: Unknown binary operation" << std::endl;
            break;
    }
    
    // 存储结果到目标操作数
    storeRegister("a0", instr->result);
}

void CodeGenerator::processUnaryOp(const std::shared_ptr<UnaryOpInstr>& instr) {
    emitComment(instr->toString());
    
    // 加载操作数到a0
    loadOperand(instr->operand, "a0");
    
    // 根据操作码生成相应的指令
    switch (instr->opcode) {
        case OpCode::NEG:
            emitInstruction("neg a0, a0");
            break;
        case OpCode::NOT:
            emitInstruction("seqz a0, a0");
            break;
        default:
            std::cerr << "Error: Unknown unary operation" << std::endl;
            break;
    }
    
    // 存储结果到目标操作数
    storeRegister("a0", instr->result);
}

void CodeGenerator::processAssign(const std::shared_ptr<AssignInstr>& instr) {
    emitComment(instr->toString());
    
    // 加载源操作数到a0
    loadOperand(instr->source, "a0");
    
    // 存储a0到目标操作数
    storeRegister("a0", instr->target);
}

void CodeGenerator::processGoto(const std::shared_ptr<GotoInstr>& instr) {
    emitComment(instr->toString());
    
    // 直接跳转到目标标签
    emitInstruction("j " + instr->target->name);
}

void CodeGenerator::processIfGoto(const std::shared_ptr<IfGotoInstr>& instr) {
    emitComment(instr->toString());
    
    // 加载条件到a0
    loadOperand(instr->condition, "a0");
    
    // 如果条件为真（非零），则跳转到目标标签
    emitInstruction("bnez a0, " + instr->target->name);
}

void CodeGenerator::processParam(const std::shared_ptr<ParamInstr>& instr) {
    emitComment(instr->toString());
    
    // 处理函数参数，这里我们假设参数是通过栈传递的
    // 在调用过程中会用到这些参数
    
    // 将参数加载到a0
    loadOperand(instr->param, "a0");
    
    // 将参数压入栈中（由CALL指令处理）
    // 这里只需要记录参数即可
}

void CodeGenerator::processCall(const std::shared_ptr<CallInstr>& instr) {
    emitComment(instr->toString());
    
    // 调用函数前需要保存调用者保存的寄存器
    emitInstruction("sw ra, -4(sp)");
    emitInstruction("addi sp, sp, -4");
    
    // 调用函数
    emitInstruction("call " + instr->funcName);
    
    // 恢复寄存器
    emitInstruction("addi sp, sp, 4");
    emitInstruction("lw ra, -4(sp)");
    
    // 如果有返回值，存储a0到结果操作数
    if (instr->result) {
        storeRegister("a0", instr->result);
    }
}

void CodeGenerator::processReturn(const std::shared_ptr<ReturnInstr>& instr) {
    emitComment(instr->toString());
    
    // 如果有返回值，加载到a0
    if (instr->value) {
        loadOperand(instr->value, "a0");
    }
    
    // 函数返回，跳转到函数结束处理
    emitInstruction("j " + currentFunction + "_epilogue");
}

void CodeGenerator::processLabel(const std::shared_ptr<LabelInstr>& instr) {
    // 生成标签
    output << instr->label << ":\n";
}

void CodeGenerator::processFunctionBegin(const std::shared_ptr<FunctionBeginInstr>& instr) {
    currentFunction = instr->funcName;
    stackSize = 0;
    localVars.clear();
    
    // 生成函数标签
    output << "\t.global " << instr->funcName << "\n";
    output << instr->funcName << ":\n";
    
    // 函数序言
    emitComment("Function prologue");
    emitInstruction("sw ra, -4(sp)");
    emitInstruction("sw fp, -8(sp)");
    emitInstruction("addi fp, sp, -4");
    emitInstruction("addi sp, sp, -8");  // 临时保存空间大小，后面会更新
    
    // 后续在函数体中会根据局部变量调整栈大小
}

void CodeGenerator::processFunctionEnd(const std::shared_ptr<FunctionEndInstr>& instr) {
    // 函数结束标签
    output << currentFunction << "_epilogue:\n";
    
    // 函数后记
    emitComment("Function epilogue");
    emitInstruction("addi sp, fp, 4");
    emitInstruction("lw fp, -4(fp)");
    emitInstruction("lw ra, 0(fp)");
    emitInstruction("ret");
    
    // 添加一行空行以提高可读性
    output << "\n";
}

void CodeGenerator::loadOperand(const std::shared_ptr<Operand>& op, const std::string& reg) {
    switch (op->type) {
        case OperandType::CONSTANT:
            emitInstruction("li " + reg + ", " + std::to_string(op->value));
            break;
            
        case OperandType::VARIABLE:
        case OperandType::TEMP:
            {
                int offset = getOperandOffset(op);
                emitInstruction("lw " + reg + ", " + std::to_string(offset) + "(fp)");
            }
            break;
            
        case OperandType::LABEL:
            // 标签通常不直接加载，而是用于跳转
            std::cerr << "Warning: Attempting to load a label operand" << std::endl;
            break;
            
        default:
            std::cerr << "Error: Unknown operand type" << std::endl;
            break;
    }
}

void CodeGenerator::storeRegister(const std::string& reg, const std::shared_ptr<Operand>& op) {
    if (op->type == OperandType::VARIABLE || op->type == OperandType::TEMP) {
        int offset = getOperandOffset(op);
        emitInstruction("sw " + reg + ", " + std::to_string(offset) + "(fp)");
    } else {
        std::cerr << "Error: Cannot store to non-variable operand" << std::endl;
    }
}

int CodeGenerator::getOperandOffset(const std::shared_ptr<Operand>& op) {
    if (op->type != OperandType::VARIABLE && op->type != OperandType::TEMP) {
        std::cerr << "Error: Only variables and temporaries have stack offsets" << std::endl;
        return 0;
    }
    
    auto it = localVars.find(op->name);
    if (it != localVars.end()) {
        return it->second;
    }
    
    // 为变量分配栈空间
    stackSize += 4;
    int offset = -8 - stackSize;  // -8 是因为前8个字节用于保存ra和fp
    localVars[op->name] = offset;
    
    // 更新函数序言中的栈大小
    return offset;
}